# Generated by the gRPC Python protocol compiler plugin. DO NOT EDIT!
"""Client and server classes corresponding to protobuf-defined services."""
import grpc

import tunnel_pb2 as tunnel__pb2


class TunnelServiceStub(object):
    """A gRPC service which can tunnel gRPC traffic from the client to the server or
    even the server to the client. A "tunnel" is a gRPC stream which presents
    itself as a gRPC transport -- over which other streams may be multiplexed.

    Note that evolution of features in this service relies on the client and
    server negotiating a "protocol revision". This negotiation step was not
    originally present, and was added in revision one, which also includes
    support for flow control, which fixes several classes of deadlock that
    can occur in heavy usage of streams on the tunnel.

    Revision one also advertises that clients can accept server settings and
    that servers intend to send them via headers. This is done by sending a
    header named "grpctunnel-negotiate" with a value of "on", both in request
    headers from a network client and in response headers from a network
    server, on the RPC that establishes the tunnel.

    Both the client and server must advertise this ability in order for a
    server settings message to actually be sent. Otherwise, clients and servers
    that implement revision one will fall back to a revision zero compatibility
    mode. (Revision zero supports neither server settings messages nor flow
    control.)

    As features are added to the protocol in future revisions, they will be
    enabled via the client and server negotiating them via the server settings
    message. The server announces what protocol revisions it supports, so the
    client can fall back to older revisions if the server doesn't support the
    latest. The client indicates the actual revision it will use in messages
    that create new streams.
    """

    def __init__(self, channel):
        """Constructor.

        Args:
            channel: A grpc.Channel.
        """
        self.OpenTunnel = channel.stream_stream(
                '/grpctunnel.v1.TunnelService/OpenTunnel',
                request_serializer=tunnel__pb2.ClientToServer.SerializeToString,
                response_deserializer=tunnel__pb2.ServerToClient.FromString,
                )
        self.OpenReverseTunnel = channel.stream_stream(
                '/grpctunnel.v1.TunnelService/OpenReverseTunnel',
                request_serializer=tunnel__pb2.ServerToClient.SerializeToString,
                response_deserializer=tunnel__pb2.ClientToServer.FromString,
                )


class TunnelServiceServicer(object):
    """A gRPC service which can tunnel gRPC traffic from the client to the server or
    even the server to the client. A "tunnel" is a gRPC stream which presents
    itself as a gRPC transport -- over which other streams may be multiplexed.

    Note that evolution of features in this service relies on the client and
    server negotiating a "protocol revision". This negotiation step was not
    originally present, and was added in revision one, which also includes
    support for flow control, which fixes several classes of deadlock that
    can occur in heavy usage of streams on the tunnel.

    Revision one also advertises that clients can accept server settings and
    that servers intend to send them via headers. This is done by sending a
    header named "grpctunnel-negotiate" with a value of "on", both in request
    headers from a network client and in response headers from a network
    server, on the RPC that establishes the tunnel.

    Both the client and server must advertise this ability in order for a
    server settings message to actually be sent. Otherwise, clients and servers
    that implement revision one will fall back to a revision zero compatibility
    mode. (Revision zero supports neither server settings messages nor flow
    control.)

    As features are added to the protocol in future revisions, they will be
    enabled via the client and server negotiating them via the server settings
    message. The server announces what protocol revisions it supports, so the
    client can fall back to older revisions if the server doesn't support the
    latest. The client indicates the actual revision it will use in messages
    that create new streams.
    """

    def OpenTunnel(self, request_iterator, context):
        """OpenTunnel creates a channel to the server which can be used to send
        additional RPCs, all of which will be sent to the same server via a
        single underlying gRPC stream. This can provide affinity for a "chatty"
        sequence of calls, where the gRPC connection is load balanced (so there
        may be multiple backend servers), but a particular "conversation" (which
        may consist of numerous RPCs) needs to all go to a single server, for
        consistency.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def OpenReverseTunnel(self, request_iterator, context):
        """OpenReverseTunnel creates a "reverse" channel, which allows the server to
        act as a client and send RPCs to the client that creates the tunnel. It
        is in most respects identical to OpenTunnel except that the roles are
        reversed: the server initiates RPCs and sends requests and the client
        replies to them and sends responses.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')


def add_TunnelServiceServicer_to_server(servicer, server):
    rpc_method_handlers = {
            'OpenTunnel': grpc.stream_stream_rpc_method_handler(
                    servicer.OpenTunnel,
                    request_deserializer=tunnel__pb2.ClientToServer.FromString,
                    response_serializer=tunnel__pb2.ServerToClient.SerializeToString,
            ),
            'OpenReverseTunnel': grpc.stream_stream_rpc_method_handler(
                    servicer.OpenReverseTunnel,
                    request_deserializer=tunnel__pb2.ServerToClient.FromString,
                    response_serializer=tunnel__pb2.ClientToServer.SerializeToString,
            ),
    }
    generic_handler = grpc.method_handlers_generic_handler(
            'grpctunnel.v1.TunnelService', rpc_method_handlers)
    server.add_generic_rpc_handlers((generic_handler,))


 # This class is part of an EXPERIMENTAL API.
class TunnelService(object):
    """A gRPC service which can tunnel gRPC traffic from the client to the server or
    even the server to the client. A "tunnel" is a gRPC stream which presents
    itself as a gRPC transport -- over which other streams may be multiplexed.

    Note that evolution of features in this service relies on the client and
    server negotiating a "protocol revision". This negotiation step was not
    originally present, and was added in revision one, which also includes
    support for flow control, which fixes several classes of deadlock that
    can occur in heavy usage of streams on the tunnel.

    Revision one also advertises that clients can accept server settings and
    that servers intend to send them via headers. This is done by sending a
    header named "grpctunnel-negotiate" with a value of "on", both in request
    headers from a network client and in response headers from a network
    server, on the RPC that establishes the tunnel.

    Both the client and server must advertise this ability in order for a
    server settings message to actually be sent. Otherwise, clients and servers
    that implement revision one will fall back to a revision zero compatibility
    mode. (Revision zero supports neither server settings messages nor flow
    control.)

    As features are added to the protocol in future revisions, they will be
    enabled via the client and server negotiating them via the server settings
    message. The server announces what protocol revisions it supports, so the
    client can fall back to older revisions if the server doesn't support the
    latest. The client indicates the actual revision it will use in messages
    that create new streams.
    """

    @staticmethod
    def OpenTunnel(request_iterator,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.stream_stream(request_iterator, target, '/grpctunnel.v1.TunnelService/OpenTunnel',
            tunnel__pb2.ClientToServer.SerializeToString,
            tunnel__pb2.ServerToClient.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def OpenReverseTunnel(request_iterator,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.stream_stream(request_iterator, target, '/grpctunnel.v1.TunnelService/OpenReverseTunnel',
            tunnel__pb2.ServerToClient.SerializeToString,
            tunnel__pb2.ClientToServer.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
